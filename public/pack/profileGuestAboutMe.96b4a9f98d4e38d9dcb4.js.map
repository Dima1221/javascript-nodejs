{"version":3,"sources":["webpack:///profileGuestAboutMe.96b4a9f98d4e38d9dcb4.js","webpack:///./handlers/profileGuest/client/aboutMe.js","webpack:///./handlers/courses/client/lib/feedbackLoader.js?56b3*","webpack:///./modules/client/xhr.js?3b46************","webpack:///./modules/client/getCsrfCookie.js?4a20************"],"names":["profileGuestAboutMe","webpackJsonp_name_",0,"module","exports","__webpack_require__","init","window","FEEDBACK_LIST_INIT","FeedbackLoader",172,"_classCallCheck","instance","Constructor","TypeError","_createClass","defineProperties","target","props","i","length","descriptor","enumerable","configurable","writable","Object","defineProperty","key","protoProps","staticProps","prototype","xhr","_ref","_this","this","elem","filter","container","querySelector","baseUrl","reset","addEventListener","e","onScroll","value","count","total","hasMore","innerHTML","load","getBoundingClientRect","bottom","document","documentElement","clientHeight","isLoading","_this2","url","request","method","json","classList","add","remove","event","undefined","result","insertAdjacentHTML","html","dispatchEvent","CustomEvent","bubbles","detail","loader",446,"options","wrapEvent","name","originalEvent","fail","reason","success","XMLHttpRequest","body","open","sync","csrfCookie","getCsrfCookie","skipCsrf","setRequestHeader","toString","call","JSON","stringify","noDocumentEvents","timeStart","Date","now","raw","normalStatuses","status","indexOf","responseText","contentType","getResponseHeader","match","parse","setTimeout","send","notification","Error",447,"cookie"],"mappings":"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","file":"profileGuestAboutMe.96b4a9f98d4e38d9dcb4.js","sourcesContent":["var profileGuestAboutMe =\nwebpackJsonp_name_([22],{\n\n/***/ 0:\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tvar FeedbackLoader = __webpack_require__(172);\n\t\n\tfunction init() {\n\t\n\t  if (window.FEEDBACK_LIST_INIT) {\n\t    new FeedbackLoader(window.FEEDBACK_LIST_INIT);\n\t  }\n\t}\n\t\n\tinit();\n\n/***/ },\n\n/***/ 172:\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tvar _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();\n\t\n\tfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }\n\t\n\tvar xhr = __webpack_require__(446);\n\t\n\tvar FeedbackLoader = (function () {\n\t  function FeedbackLoader(_ref) {\n\t    var _this = this;\n\t\n\t    var elem = _ref.elem;\n\t    var filter = _ref.filter;\n\t\n\t    _classCallCheck(this, FeedbackLoader);\n\t\n\t    this.elem = elem;\n\t    this.container = elem.querySelector('[data-feedback-container]');\n\t    this.baseUrl = '/courses/feedback-fetch';\n\t\n\t    this.reset(filter);\n\t\n\t    window.addEventListener('scroll', function (e) {\n\t      return _this.onScroll(e);\n\t    });\n\t  }\n\t\n\t  _createClass(FeedbackLoader, [{\n\t    key: 'reset',\n\t    value: function reset(filter) {\n\t      this.filter = filter;\n\t\n\t      this.count = 0;\n\t\n\t      this.total = null;\n\t\n\t      this.hasMore = true;\n\t\n\t      this.container.innerHTML = '';\n\t      this.load();\n\t    }\n\t  }, {\n\t    key: 'onScroll',\n\t    value: function onScroll() {\n\t      if (!this.hasMore) return;\n\t\n\t      if (this.container.getBoundingClientRect().bottom <= document.documentElement.clientHeight && !this.isLoading) {\n\t        this.load();\n\t      }\n\t    }\n\t  }, {\n\t    key: 'load',\n\t    value: function load() {\n\t      var _this2 = this;\n\t\n\t      var url = this.baseUrl + '?skip=' + this.count + '&needTotal=' + (this.total === null ? 1 : 0);\n\t\n\t      for (var key in this.filter) {\n\t        url += '&' + key + '=' + this.filter[key];\n\t      }\n\t\n\t      var request = xhr({\n\t        method: 'GET',\n\t        json: true,\n\t        url: url\n\t      });\n\t\n\t      this.elem.classList.add('course-feedbacks_loading');\n\t\n\t      this.isLoading = true;\n\t\n\t      request.addEventListener('loadend', function () {\n\t        _this2.isLoading = false;\n\t        _this2.elem.classList.remove('course-feedbacks_loading');\n\t      });\n\t\n\t      request.addEventListener('success', function (event) {\n\t        if (event.result.total !== undefined) {\n\t          _this2.total = event.result.total;\n\t        }\n\t\n\t        if (event.result.count) {\n\t          _this2.container.insertAdjacentHTML(\"beforeEnd\", event.result.html);\n\t          _this2.count += event.result.count;\n\t        } else if (!_this2.count) {\n\t          // if multiple load calls hit it => no multi-append\n\t          _this2.container.innerHTML = '<p style=\"text-align:center\">Отзывов пока нет.</p>';\n\t        }\n\t\n\t        if (event.result.hasMore === false) {\n\t          _this2.hasMore = false;\n\t        }\n\t\n\t        _this2.elem.dispatchEvent(new CustomEvent('feedbackChange', {\n\t          bubbles: true,\n\t          detail: {\n\t            loader: _this2\n\t          }\n\t        }));\n\t      });\n\t    }\n\t  }]);\n\t\n\t  return FeedbackLoader;\n\t})();\n\t\n\tmodule.exports = FeedbackLoader;\n\n/***/ },\n\n/***/ 446:\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tvar notification = __webpack_require__(440);\n\tvar getCsrfCookie = __webpack_require__(447);\n\t// Wrapper about XHR\n\t// # Global Events\n\t// triggers document.loadstart/loadend on communication start/end\n\t//    --> unless options.noGlobalEvents is set\n\t//\n\t// # Events\n\t// triggers fail/success on load end:\n\t//    --> by default status=200 is ok, the others are failures\n\t//    --> options.normalStatuses = [201,409] allow given statuses\n\t//    --> fail event has .reason field\n\t//    --> success event has .result field\n\t//\n\t// # JSON\n\t//    --> send(object) calls JSON.stringify\n\t//    --> adds Accept: json (we want json) by default, unless options.raw\n\t// if options.json or server returned json content type\n\t//    --> autoparse json\n\t//    --> fail if error\n\t//\n\t// # CSRF\n\t//    --> requests sends header X-XSRF-TOKEN from cookie\n\t\n\tfunction xhr(options) {\n\t\n\t  var request = new XMLHttpRequest();\n\t\n\t  var method = options.method || 'GET';\n\t\n\t  var body = options.body;\n\t  var url = options.url;\n\t\n\t  request.open(method, url, options.sync ? false : true);\n\t\n\t  request.method = method;\n\t\n\t  // token/header names same as angular $http for easier interop\n\t  var csrfCookie = getCsrfCookie();\n\t  if (csrfCookie && !options.skipCsrf) {\n\t    request.setRequestHeader(\"X-XSRF-TOKEN\", csrfCookie);\n\t  }\n\t\n\t  if (({}).toString.call(body) == '[object Object]') {\n\t    // must be OPENed to setRequestHeader\n\t    request.setRequestHeader(\"Content-Type\", \"application/json;charset=UTF-8\");\n\t    body = JSON.stringify(body);\n\t  }\n\t\n\t  if (!options.noDocumentEvents) {\n\t    request.addEventListener('loadstart', function (event) {\n\t      request.timeStart = Date.now();\n\t      var e = wrapEvent('xhrstart', event);\n\t      document.dispatchEvent(e);\n\t    });\n\t    request.addEventListener('loadend', function (event) {\n\t      var e = wrapEvent('xhrend', event);\n\t      document.dispatchEvent(e);\n\t    });\n\t    request.addEventListener('success', function (event) {\n\t      var e = wrapEvent('xhrsuccess', event);\n\t      e.result = event.result;\n\t      document.dispatchEvent(e);\n\t    });\n\t    request.addEventListener('fail', function (event) {\n\t      var e = wrapEvent('xhrfail', event);\n\t      e.reason = event.reason;\n\t      document.dispatchEvent(e);\n\t    });\n\t  }\n\t\n\t  if (!options.raw) {\n\t    // means we want json\n\t    request.setRequestHeader(\"Accept\", \"application/json\");\n\t  }\n\t\n\t  request.setRequestHeader('X-Requested-With', \"XMLHttpRequest\");\n\t\n\t  var normalStatuses = options.normalStatuses || [200];\n\t\n\t  function wrapEvent(name, e) {\n\t    var event = new CustomEvent(name);\n\t    event.originalEvent = e;\n\t    return event;\n\t  }\n\t\n\t  function fail(reason, originalEvent) {\n\t    var e = wrapEvent(\"fail\", originalEvent);\n\t    e.reason = reason;\n\t    request.dispatchEvent(e);\n\t  }\n\t\n\t  function success(result, originalEvent) {\n\t    var e = wrapEvent(\"success\", originalEvent);\n\t    e.result = result;\n\t    request.dispatchEvent(e);\n\t  }\n\t\n\t  request.addEventListener(\"error\", function (e) {\n\t    fail(\"Ошибка связи с сервером.\", e);\n\t  });\n\t\n\t  request.addEventListener(\"timeout\", function (e) {\n\t    fail(\"Превышено максимально допустимое время ожидания ответа от сервера.\", e);\n\t  });\n\t\n\t  request.addEventListener(\"abort\", function (e) {\n\t    fail(\"Запрос был прерван.\", e);\n\t  });\n\t\n\t  request.addEventListener(\"load\", function (e) {\n\t    if (!request.status) {\n\t      // does that ever happen?\n\t      fail(\"Не получен ответ от сервера.\", e);\n\t      return;\n\t    }\n\t\n\t    if (normalStatuses.indexOf(request.status) == -1) {\n\t      fail(\"Ошибка на стороне сервера (код \" + request.status + \"), попытайтесь позднее.\", e);\n\t      return;\n\t    }\n\t\n\t    var result = request.responseText;\n\t    var contentType = request.getResponseHeader(\"Content-Type\");\n\t    if (contentType.match(/^application\\/json/) || options.json) {\n\t      // autoparse json if WANT or RECEIVED json\n\t      try {\n\t        result = JSON.parse(result);\n\t      } catch (e) {\n\t        fail(\"Некорректный формат ответа от сервера.\", e);\n\t        return;\n\t      }\n\t    }\n\t\n\t    success(result, e);\n\t  });\n\t\n\t  // defer to let other handlers be assigned\n\t  setTimeout(function () {\n\t    request.send(body);\n\t  }, 0);\n\t\n\t  return request;\n\t}\n\t\n\tdocument.addEventListener('xhrfail', function (event) {\n\t  new notification.Error(event.reason);\n\t});\n\t\n\tmodule.exports = xhr;\n\n/***/ },\n\n/***/ 447:\n/***/ function(module, exports) {\n\n\t\"use strict\";\n\t\n\tmodule.exports = function () {\n\t  var csrfCookie = document.cookie.match(/XSRF-TOKEN=([\\w-]+)/);\n\t  return csrfCookie ? csrfCookie[1] : null;\n\t};\n\n/***/ }\n\n});\n\n\n/** WEBPACK FOOTER **\n ** profileGuestAboutMe.96b4a9f98d4e38d9dcb4.js\n **/","var FeedbackLoader = require('courses/client/lib/feedbackLoader');\n\nfunction init() {\n\n  if (window.FEEDBACK_LIST_INIT) {\n    new FeedbackLoader(window.FEEDBACK_LIST_INIT);\n  }\n\n}\n\n\ninit();\n\n\n\n/** WEBPACK FOOTER **\n ** ./handlers/profileGuest/client/aboutMe.js\n **/","var xhr = require('client/xhr');\n\nclass FeedbackLoader {\n\n  constructor({elem, filter}) {\n\n    this.elem = elem;\n    this.container = elem.querySelector('[data-feedback-container]');\n    this.baseUrl = `/courses/feedback-fetch`;\n\n    this.reset(filter);\n\n    window.addEventListener('scroll', e => this.onScroll(e));\n  }\n\n  reset(filter) {\n    this.filter = filter;\n\n    this.count = 0;\n\n    this.total = null;\n\n    this.hasMore = true;\n\n    this.container.innerHTML = '';\n    this.load();\n  }\n\n  onScroll() {\n    if (!this.hasMore) return;\n\n    if (this.container.getBoundingClientRect().bottom <= document.documentElement.clientHeight && !this.isLoading) {\n      this.load();\n    }\n  }\n\n  load() {\n\n    let url = `${this.baseUrl}?skip=${this.count}&needTotal=${this.total === null ? 1 : 0}`;\n\n    for (var key in this.filter) {\n      url += `&${key}=${this.filter[key]}`;\n    }\n\n    const request = xhr({\n      method: 'GET',\n      json:   true,\n      url:    url\n    });\n\n    this.elem.classList.add('course-feedbacks_loading');\n\n    this.isLoading = true;\n\n    request.addEventListener('loadend', () => {\n      this.isLoading = false;\n      this.elem.classList.remove('course-feedbacks_loading');\n    });\n\n    request.addEventListener('success', (event) => {\n      if (event.result.total !== undefined) {\n        this.total = event.result.total;\n      }\n\n      if (event.result.count) {\n        this.container.insertAdjacentHTML(\"beforeEnd\", event.result.html);\n        this.count += event.result.count;\n      } else if (!this.count) {\n        // if multiple load calls hit it => no multi-append\n        this.container.innerHTML = `<p style=\"text-align:center\">Отзывов пока нет.</p>`;\n      }\n\n      if (event.result.hasMore === false) {\n        this.hasMore = false;\n      }\n\n      this.elem.dispatchEvent(new CustomEvent('feedbackChange', {\n        bubbles: true,\n        detail: {\n          loader: this\n        }\n      }));\n\n    });\n\n  }\n\n}\n\nmodule.exports = FeedbackLoader;\n\n\n\n/** WEBPACK FOOTER **\n ** ./handlers/courses/client/lib/feedbackLoader.js\n **/","var notification = require('client/notification');\nvar getCsrfCookie = require('client/getCsrfCookie');\n// Wrapper about XHR\n// # Global Events\n// triggers document.loadstart/loadend on communication start/end\n//    --> unless options.noGlobalEvents is set\n//\n// # Events\n// triggers fail/success on load end:\n//    --> by default status=200 is ok, the others are failures\n//    --> options.normalStatuses = [201,409] allow given statuses\n//    --> fail event has .reason field\n//    --> success event has .result field\n//\n// # JSON\n//    --> send(object) calls JSON.stringify\n//    --> adds Accept: json (we want json) by default, unless options.raw\n// if options.json or server returned json content type\n//    --> autoparse json\n//    --> fail if error\n//\n// # CSRF\n//    --> requests sends header X-XSRF-TOKEN from cookie\n\nfunction xhr(options) {\n\n  var request = new XMLHttpRequest();\n\n  var method = options.method || 'GET';\n\n  var body = options.body;\n  var url = options.url;\n\n  request.open(method, url, options.sync ? false : true);\n\n  request.method = method;\n\n  // token/header names same as angular $http for easier interop\n  var csrfCookie = getCsrfCookie();\n  if (csrfCookie && !options.skipCsrf) {\n    request.setRequestHeader(\"X-XSRF-TOKEN\", csrfCookie);\n  }\n\n  if ({}.toString.call(body) == '[object Object]') {\n    // must be OPENed to setRequestHeader\n    request.setRequestHeader(\"Content-Type\", \"application/json;charset=UTF-8\");\n    body = JSON.stringify(body);\n  }\n\n  if (!options.noDocumentEvents) {\n    request.addEventListener('loadstart', event => {\n      request.timeStart = Date.now();\n      var e = wrapEvent('xhrstart', event);\n      document.dispatchEvent(e);\n    });\n    request.addEventListener('loadend', event => {\n      var e = wrapEvent('xhrend', event);\n      document.dispatchEvent(e);\n    });\n    request.addEventListener('success', event => {\n      var e = wrapEvent('xhrsuccess', event);\n      e.result = event.result;\n      document.dispatchEvent(e);\n    });\n    request.addEventListener('fail', event => {\n      var e = wrapEvent('xhrfail', event);\n      e.reason = event.reason;\n      document.dispatchEvent(e);\n    });\n  }\n\n  if (!options.raw) { // means we want json\n    request.setRequestHeader(\"Accept\", \"application/json\");\n  }\n\n  request.setRequestHeader('X-Requested-With', \"XMLHttpRequest\");\n\n  var normalStatuses = options.normalStatuses || [200];\n\n  function wrapEvent(name, e) {\n    var event = new CustomEvent(name);\n    event.originalEvent = e;\n    return event;\n  }\n\n  function fail(reason, originalEvent) {\n    var e = wrapEvent(\"fail\", originalEvent);\n    e.reason = reason;\n    request.dispatchEvent(e);\n  }\n\n  function success(result, originalEvent) {\n    var e = wrapEvent(\"success\", originalEvent);\n    e.result = result;\n    request.dispatchEvent(e);\n  }\n\n  request.addEventListener(\"error\", e => {\n    fail(\"Ошибка связи с сервером.\", e);\n  });\n\n  request.addEventListener(\"timeout\", e => {\n    fail(\"Превышено максимально допустимое время ожидания ответа от сервера.\", e);\n  });\n\n  request.addEventListener(\"abort\", e => {\n    fail(\"Запрос был прерван.\", e);\n  });\n\n  request.addEventListener(\"load\", e => {\n    if (!request.status) { // does that ever happen?\n      fail(\"Не получен ответ от сервера.\", e);\n      return;\n    }\n\n    if (normalStatuses.indexOf(request.status) == -1) {\n      fail(\"Ошибка на стороне сервера (код \" + request.status + \"), попытайтесь позднее.\", e);\n      return;\n    }\n\n    var result = request.responseText;\n    var contentType = request.getResponseHeader(\"Content-Type\");\n    if (contentType.match(/^application\\/json/) || options.json) { // autoparse json if WANT or RECEIVED json\n      try {\n        result = JSON.parse(result);\n      } catch (e) {\n        fail(\"Некорректный формат ответа от сервера.\", e);\n        return;\n      }\n    }\n\n    success(result, e);\n  });\n\n  // defer to let other handlers be assigned\n  setTimeout(function() {\n    request.send(body);\n  }, 0);\n\n  return request;\n\n}\n\n\ndocument.addEventListener('xhrfail', function(event) {\n  new notification.Error(event.reason);\n});\n\n\nmodule.exports = xhr;\n\n\n\n/** WEBPACK FOOTER **\n ** ./modules/client/xhr.js\n **/","module.exports = function() {\n  var csrfCookie = document.cookie.match(/XSRF-TOKEN=([\\w-]+)/);\n  return csrfCookie ? csrfCookie[1] : null;\n};\n\n\n\n\n/** WEBPACK FOOTER **\n ** ./modules/client/getCsrfCookie.js\n **/"],"sourceRoot":""}